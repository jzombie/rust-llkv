name: rust-bench

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  # Manual trigger so you can run the workflow from the Actions tab
  workflow_dispatch: {}

# Grant the minimum permissions required for the action to create PR comments.
# By default GITHUB_TOKEN is read-only for many scopes; explicitly allow write
# access to issues/pull-requests so Bencher can post comments on PRs.
# Note: For runs triggered by forks, secrets (including GITHUB_TOKEN) are not
# available and commenting will fail â€” this is a GitHub security restriction.
#
# https://bencher.dev/docs/explanation/bencher-run/#--github-actions-github_token
permissions:
  pull-requests: write
  checks: write

# Ensure only one run per branch/PR at a time. If new commits are pushed,
# older jobs will be automatically canceled.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  bench:
    name: bench
    # Only run this job for non-draft pull requests. We still want the job to run
    # for pushes and manual `workflow_dispatch` events. GitHub exposes
    # `github.event.pull_request.draft` (true for draft PRs), so require it to
    # be false when the event is a pull_request.
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.draft == false }}

    # runs-on: ubuntu-latest
    runs-on: [self-hosted, macOS, ARM64]
    env:
      BENCHER_PROJECT: llkv
      # The Bencher adapter to use for the benchmark run.
      # https://bencher.dev/docs/explanation/adapters
      BENCHER_ADAPTER: rust_criterion
      BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}
      # Use a workspace-local CARGO_HOME to avoid writing into the runner's
      # $HOME/.cargo. This keeps installs and registry/git cache inside the
      # repository workspace (useful for self-hosted runners).
      CARGO_HOME: "${{ github.workspace }}/.cargo"
      # The branch name to report to Bencher. For pull_request events use the
      # head ref, otherwise use the ref name (branch on push).
      BENCHER_BRANCH: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
      # A simple testbed identifier. You can change this to better describe the
      # runner (eg: self-hosted-mac-arm64, github-ubuntu-latest, etc.).
      BENCHER_TESTBED: ci
      # Optional: set threshold flags here to create Thresholds/Models when the
      # bench run executes. Leave empty to skip creating/updating Thresholds.
      # https://bencher.dev/docs/explanation/thresholds/
      THRESHOLD_FLAGS: --threshold-measure latency --threshold-test t_test --threshold-max-sample-size 64 --threshold-upper-boundary 0.99 --thresholds-reset --err
      # Configure sccache to use local disk storage for self-hosted runners.
      # This persists the cache across workflow runs on the same runner.
      SCCACHE_DIR: "${{ github.workspace }}/.sccache"
      SCCACHE_CACHE_SIZE: "5G"
      # Ensure every cargo invocation in the job goes through sccache
      RUSTC_WRAPPER: sccache
      # Use a consistent target directory so artifacts are shared across steps
      CARGO_TARGET_DIR: "${{ github.workspace }}/target"
    steps:
      - uses: actions/checkout@v4

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ${{ env.CARGO_HOME }}/bin/
            ${{ env.CARGO_HOME }}/registry/index/
            ${{ env.CARGO_HOME }}/registry/cache/
            ${{ env.CARGO_HOME }}/git/db/
            ${{ env.SCCACHE_DIR }}
            target/
          # Cache scoped to OS + ARCH and invalidated when Cargo.lock or
          # rust-toolchain files change. We intentionally do NOT cache
          # `target/` here because sccache provides compiled-object caching
          # and caching `target/` can lead to incompatible incremental files.
          key: ${{ runner.os }}-${{ runner.arch }}-cargo-${{ hashFiles('**/Cargo.lock','**/rust-toolchain*') }}
          restore-keys: |
            ${{ runner.os }}-${{ runner.arch }}-cargo-${{ hashFiles('**/Cargo.lock','**/rust-toolchain*') }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add cargo bin to PATH
        run: |
          mkdir -p "${CARGO_HOME}/bin"
          echo "${CARGO_HOME}/bin" >> "$GITHUB_PATH"

      - name: Ensure sccache directory
        run: mkdir -p "$SCCACHE_DIR"

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Install cargo-binstall
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v cargo-binstall >/dev/null 2>&1; then
            curl -sSfL https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
          fi

      - name: Install cargo-workspaces
        shell: bash
        run: |
          set -euo pipefail
          cargo binstall --no-confirm --no-symlinks --force cargo-workspaces \
            || cargo install --locked --force cargo-workspaces

      - name: Detect changed crates
        id: detect
        # This uses `cargo-workspaces` to find crates changed since the base
        # ref of the current PR (or `origin/main` for pushes). It writes a
        # space-separated list of crate names to the `packages` output. If no
        # crates changed the output will be empty.
        run: |
          set -euo pipefail

          # Ensure we can compare against origin/main or the PR base
          git fetch --no-tags --prune origin "+refs/heads/*:refs/remotes/origin/*"

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            SINCE="${{ github.event.pull_request.base.sha }}"
          else
            SINCE="origin/main"
          fi

          # Run detection, produce a JSON array (fallback to empty array on error)
          PACKAGES_JSON=$(cargo workspaces changed --json --since "$SINCE" 2>/dev/null || echo '[]')

          # Convert JSON array to a simple space-separated list of crate names
          # Use the default (plain-text) output of `cargo workspaces changed`.
          # It lists one crate name per line; convert to a space-separated list.
          PACKAGES=$(cargo workspaces changed --since "$SINCE" 2>/dev/null | paste -sd ' ' - || true)

          echo "detected packages: $PACKAGES"
          echo "packages=$PACKAGES" >> "$GITHUB_OUTPUT"

      - uses: bencherdev/bencher@main
      - name: Run benches directly
        id: run-benches
        env:
          PACKAGES: ${{ steps.detect.outputs.packages }}
        run: |
          set -euo pipefail

          if [ -z "${PACKAGES}" ]; then
            echo "No changed crates detected; skipping bench run."
            exit 0
          fi

          # Build a single cargo bench invocation with -p flags for all
          # detected packages. Running one cargo process avoids duplicate
          # dependency resolution and compilation across multiple cargo
          # invocations and helps sccache reuse.
          PACKAGE_FLAGS=()
          for p in $PACKAGES; do
            PACKAGE_FLAGS+=("-p" "$p")
          done

          # Populate (no-run) using a single cargo invocation
          echo "Populating sccache for packages: $PACKAGES"
          echo "+ cargo bench ${PACKAGE_FLAGS[@]} --no-run"
          cargo bench "${PACKAGE_FLAGS[@]}" --no-run || true

          # Run benches for the same set of packages via Bencher (forward cargo command)
          echo "Running benches for packages: $PACKAGES"

          # Build the bencher command as an array so we preserve quoting and
          # can easily print/inspect the exact argv that will be executed.
          BENCHER_CMD=(
            bencher run
            --adapter "${BENCHER_ADAPTER}"
            --project "${BENCHER_PROJECT}"
            --branch "${BENCHER_BRANCH}"
            --testbed "${BENCHER_TESTBED}"
          )

          # If THRESHOLD_FLAGS is set, split into words and append them.
          if [ -n "${THRESHOLD_FLAGS:-}" ]; then
            read -r -a THRESHOLD_ARR <<< "${THRESHOLD_FLAGS}"
            for t in "${THRESHOLD_ARR[@]}"; do
              BENCHER_CMD+=("$t")
            done
          fi

          # Separator and cargo bench invocation
          BENCHER_CMD+=(-- cargo bench)

          # Append package flags (eg: -p crate) to the command
          for pf in "${PACKAGE_FLAGS[@]}"; do
            BENCHER_CMD+=("$pf")
          done

          # Print the exact command (quoting preserved) for debugging
          printf '+ %q ' "${BENCHER_CMD[@]}"
          printf '\n'

          # Execute the assembled command
          "${BENCHER_CMD[@]}"

      # Show final sccache statistics after benchmark completion
      - name: Display sccache stats
        if: always()
        run: |
          echo "=== Final sccache statistics ==="
          sccache --show-stats
          echo ""
          echo "=== sccache cache directory size ==="
          du -sh "$SCCACHE_DIR" 2>/dev/null || echo "Cache directory not found"

      # Stop sccache server to clean up
      - name: Stop sccache
        if: always()
        run: sccache --stop-server || true
