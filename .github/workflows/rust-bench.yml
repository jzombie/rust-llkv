name: rust-bench

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

# Grant the minimum permissions required for the action to create PR comments.
# By default GITHUB_TOKEN is read-only for many scopes; explicitly allow write
# access to issues/pull-requests so Bencher can post comments on PRs.
# Note: For runs triggered by forks, secrets (including GITHUB_TOKEN) are not
# available and commenting will fail â€” this is a GitHub security restriction.
#
# https://bencher.dev/docs/explanation/bencher-run/#--github-actions-github_token
permissions:
  pull-requests: write
  checks: write

# Ensure only one run per branch/PR at a time. If new commits are pushed,
# older jobs will be automatically canceled.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  bench:
    name: bench
    # Only run this job for non-draft pull requests. We still want the job to run
    # for pushes and manual `workflow_dispatch` events. GitHub exposes
    # `github.event.pull_request.draft` (true for draft PRs), so require it to
    # be false when the event is a pull_request.
    if: ${{ github.event_name != 'pull_request' || github.event.pull_request.draft == false }}

    # runs-on: ubuntu-latest
    runs-on: [self-hosted, macOS, ARM64]
    env:
      BENCHER_PROJECT: llkv
      # The Bencher adapter to use for the benchmark run.
      # https://bencher.dev/docs/explanation/adapters
      BENCHER_ADAPTER: rust_criterion
      BENCHER_API_TOKEN: ${{ secrets.BENCHER_API_TOKEN }}
      # Use a workspace-local CARGO_HOME to avoid writing into the runner's
      # $HOME/.cargo. This keeps installs and registry/git cache inside the
      # repository workspace (useful for self-hosted runners).
      CARGO_HOME: "${{ github.workspace }}/.cargo"
      # The branch name to report to Bencher. For pull_request events use the
      # head ref, otherwise use the ref name (branch on push).
      BENCHER_BRANCH: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
      # A simple testbed identifier. You can change this to better describe the
      # runner (eg: self-hosted-mac-arm64, github-ubuntu-latest, etc.).
      BENCHER_TESTBED: ci
      # Optional: set threshold flags here to create Thresholds/Models when the
      # bench run executes. Leave empty to skip creating/updating Thresholds.
      # https://bencher.dev/docs/explanation/thresholds/
      THRESHOLD_FLAGS: --threshold-measure latency --threshold-test t_test --threshold-max-sample-size 64 --threshold-upper-boundary 0.99 --thresholds-reset --err
      # Configure sccache to use local disk storage for self-hosted runners.
      # This persists the cache across workflow runs on the same runner.
      SCCACHE_DIR: "${{ github.workspace }}/.sccache"
      SCCACHE_CACHE_SIZE: "5G"
    steps:
      - uses: actions/checkout@v4

      - name: Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
            ${{ env.SCCACHE_DIR }}
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}-

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add cargo bin to PATH
        run: |
          mkdir -p "${CARGO_HOME}/bin"
          echo "${CARGO_HOME}/bin" >> "$GITHUB_PATH"

      - name: Ensure sccache directory
        run: mkdir -p "$SCCACHE_DIR"

      - name: Setup sccache
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Install cargo-binstall
        shell: bash
        run: |
          set -euo pipefail
          if ! command -v cargo-binstall >/dev/null 2>&1; then
            curl -sSfL https://raw.githubusercontent.com/cargo-bins/cargo-binstall/main/install-from-binstall-release.sh | bash
          fi

      - name: Install cargo-workspaces
        shell: bash
        run: |
          set -euo pipefail
          cargo binstall --no-confirm --no-symlinks --force cargo-workspaces \
            || cargo install --locked --force cargo-workspaces

      - name: Detect changed crates
        id: detect
        # This uses `cargo-workspaces` to find crates changed since the base
        # ref of the current PR (or `origin/main` for pushes). It writes a
        # space-separated list of crate names to the `packages` output. If no
        # crates changed the output will be empty.
        run: |
          set -euo pipefail

          # Ensure we can compare against origin/main or the PR base
          git fetch --no-tags --prune origin "+refs/heads/*:refs/remotes/origin/*"

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            SINCE="${{ github.event.pull_request.base.sha }}"
          else
            SINCE="origin/main"
          fi

          # Run detection, produce a JSON array (fallback to empty array on error)
          PACKAGES_JSON=$(cargo workspaces changed --json --since "$SINCE" 2>/dev/null || echo '[]')

          # Convert JSON array to a simple space-separated list of crate names
          # Use the default (plain-text) output of `cargo workspaces changed`.
          # It lists one crate name per line; convert to a space-separated list.
          PACKAGES=$(cargo workspaces changed --since "$SINCE" 2>/dev/null | paste -sd ' ' - || true)

          echo "detected packages: $PACKAGES"
          echo "packages=$PACKAGES" >> "$GITHUB_OUTPUT"

      - uses: bencherdev/bencher@main

      - name: Run benches via Bencher
        id: run-benches
        env:
          RUSTC_WRAPPER: sccache
          PACKAGES: ${{ steps.detect.outputs.packages }}
        run: |
          set -euo pipefail

          if [ -z "${PACKAGES}" ]; then
            echo "No changed crates detected; skipping bench run."
            exit 0
          fi

          # Build the bencher command safely into an array to avoid eval/quoting issues.
          # Split threshold flags into an array so each flag is preserved as a token.
          read -r -a THRESHOLD_ARR <<<"${THRESHOLD_FLAGS}"

          BENCHER_CMD=(
            bencher
            run
            --adapter "${BENCHER_ADAPTER}"
            --project "${BENCHER_PROJECT}"
            --branch "${BENCHER_BRANCH}"
            --testbed "${BENCHER_TESTBED}"
          )

          if [ "${#THRESHOLD_ARR[@]}" -ne 0 ]; then
            BENCHER_CMD+=("${THRESHOLD_ARR[@]}")
          fi

          # If this is an in-repo PR (secrets available) append the GitHub
          # actions flag so Bencher can post a PR comment/check. This flag is
          # strictly about creating a GitHub PR comment, not uploading to
          # bencher.dev (that's controlled by BENCHER_API_TOKEN).
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.pull_request.head.repo.fork }}" = "false" ]; then
            BENCHER_CMD+=(--github-actions "${{ secrets.GITHUB_TOKEN }}")
          fi

          # We'll run Bencher separately for each changed package using
          # `--manifest-path <pkg>/Cargo.toml`. This runs `cargo bench` in
          # the context of that package's manifest which avoids building
          # unrelated workspace members. Note: this assumes the package
          # directory name matches the package name (common layout).
          for p in $PACKAGES; do
            echo "Running bencher for package: $p"
            # Call the helper script under bencher. The script will
            # run `cargo bench --manifest-path <pkg>/Cargo.toml`.
            CMD=("${BENCHER_CMD[@]}" "bash" "${GITHUB_WORKSPACE:-.}/scripts/bench-package.sh" "$p")
            echo "+ ${CMD[@]}"
            "${CMD[@]}"
          done

      # Show final sccache statistics after benchmark completion
      - name: Display sccache stats
        if: always()
        run: |
          echo "=== Final sccache statistics ==="
          sccache --show-stats
          echo ""
          echo "=== sccache cache directory size ==="
          du -sh "$SCCACHE_DIR" 2>/dev/null || echo "Cache directory not found"

      # Stop sccache server to clean up
      - name: Stop sccache
        if: always()
        run: sccache --stop-server || true
